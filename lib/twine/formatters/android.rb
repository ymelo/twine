# encoding: utf-8
require 'cgi'
require 'rexml/document'

module Twine
  module Formatters
    class Android < Abstract
      FORMAT_NAME = 'android'
      EXTENSION = '.xml'
      DEFAULT_FILE_NAME = 'strings.xml'
      LANG_CODES = Hash[
        'zh' => 'zh-Hans',
        'zh-rCN' => 'zh-Hans',
        'zh-rHK' => 'zh-Hant',
        'en-rGB' => 'en-UK',
        'in' => 'id',
        'nb' => 'no'
        # TODO: spanish
      ]
      DEFAULT_LANG_CODES = Hash[
        'zh-TW' => 'zh-Hant' # if we don't have a zh-TW translation, try zh-Hant before en
      ]

      def self.can_handle_directory?(path)
        Dir.entries(path).any? { |item| /^values.*$/.match(item) }
      end

      def default_file_name
        return DEFAULT_FILE_NAME
      end

      def determine_language_given_path(path)
        path_arr = path.split(File::SEPARATOR)
        path_arr.each do |segment|
          if segment == 'values'
            return @strings.language_codes[0]
          else
            match = /^values-(.*)$/.match(segment)
            if match
              lang = match[1]
              lang = LANG_CODES.fetch(lang, lang)
              lang.sub!('-r', '-')
              return lang
            end
          end
        end

        return
      end

      def read_file(path, lang)
        resources_regex = /<resources(?:[^>]*)>(.*)<\/resources>/m
        #matches either a string with an id, or a plural with an id
        key_regex = /<string name="(\w+)">|<plurals name="(\w+)">/
        comment_regex = /<!-- (.*) -->/
        value_regex = /<string name="\w+">(.*)<\/string>/

        key = nil
        value = nil
        comment = nil

        File.open(path, 'r:UTF-8') do |f|
          content_match = resources_regex.match(f.read)
          if content_match
            for line in content_match[1].split(/(<\/string>\r?\n|<\/plurals>\r?\n)/).each_slice(2).map(&:join)#split(/<\/string>\r?\n/)#|(?=<<\/plurals>\r?\n)/)
              key_match = key_regex.match(line)
              #puts "New line"
              puts "---------"
              if key_match
                #puts key_match[1]
                if !key_match[1].nil?
                  key = key_match[1]
                  value_match = value_regex.match(line)
                  if value_match
                    value = value_match[1]
                    unformat_value value
                  else
                    #key matched a string, but no actual string inside, adding an empty string instead
                    value = ""
                  end
                  set_translation_for_key(key, lang, value)
                else
                  #puts "line: #{line}"
                  modifier = nil
                  if !key_match[2].nil?
                    read_plural(key_match[2], lang, line)
                  end
                end
                #puts "#{key} #{value}"

                if comment and comment.length > 0 and !comment.start_with?("SECTION:")
                  set_comment_for_key(key, comment)
                end
                comment = nil
              end

              comment_match = comment_regex.match(line)
              if comment_match
                comment = comment_match[1]
              end
            end
          end
        end
      end

      def read_plural(key, lang, plural)
        plural_regex = /<plurals name="(\w+)">(.*)<\/plurals>/m

        plural_match = plural_regex.match(plural)

        #make sure that we have a plural here
        if plural_match
          key = plural_match[1]
          #added the plurals as a separate regex for now, might merge in later
          item_regex = /<item quantity="(\w+)">(.*)<\/item>/
          for line in plural_match[2].split(/\r?\n/)
            #puts line
            #matching a plural
            item_match = item_regex.match(line)
            if item_match
              #Store the whole plural block into a string, need to decide on the output format
              value = item_match[2]
              modifier = item_match[1]
              unformat_value(value)
              puts "#{key} #{lang} #{modifier} #{value}"
              set_plural_translation_for_key(key, lang, modifier, value)
            else
              #nothing to add, non matching line (blank?)
            end

          end
        end


      end

      # def set_plural_translation_for_key(key, lang, modifier, plurals)
      #   set_translation_for_key(key << "_" << modifier, lang, value)
      # end

      def fallback_languages(lang)
        [DEFAULT_LANG_CODES[lang], super].flatten.compact
      end

      def format_header(lang)
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Android Strings File -->\n<!-- Generated by Twine #{Twine::VERSION} -->\n<!-- Language: #{lang} -->"
      end

      def format_sections(lang)
        result = '<resources>'

        result += super(lang) + "\n"

        result += '</resources>'
      end

      def format_section_header(section)
        "\t<!-- SECTION: #{section.name} -->"
      end

      def format_comment(comment)
        "\t<!-- #{comment.gsub('--', 'â€”')} -->"
      end

      def key_value_pattern
        "\t<string name=\"%{key}\">%{value}</string>"
      end

      def key_plural_value_pattern
        "\t<plurals name=\"%{key}\">\n%{value}\t</plurals>"
      end

      def unformat_value(value)
        value = CGI.unescapeHTML(value)
        value.gsub!('\\\'', '\'')
        value.gsub!('\\"', '"')
        value = iosify_substitutions(value)
        value.gsub!(/(\\u0020)*|(\\u0020)*\z/) { |spaces| ' ' * (spaces.length / 6) }
      end

      def format_value(value)
        # Android enforces the following rules on the values
        #  1) apostrophes and quotes must be escaped with a backslash
        value.gsub!("'", "\\\\'")
        value.gsub!('"', '\\\\"')
        #  2) HTML escape the string
        value = CGI.escapeHTML(value)
        #  3) fix substitutions (e.g. %s/%@)
        value = androidify_substitutions(value)
        #  4) replace beginning and end spaces with \0020. Otherwise Android strips them.
        value.gsub(/\A *| *\z/) { |spaces| '\u0020' * spaces.length }
      end

      def format_plurals(values)
        result = String.new
        values.each {|key, value| result << "\t\t<item quantity=\"#{key}\">#{value}</item>\n"}
        return result
      end

      def format(key, value)
        if value.is_a?(Hash)
          key_plural_value_pattern % { key: format_key(key), value: format_plurals(value)}
        else
          key_value_pattern % { key: format_key(key), value: format_value(value) }
        end
      end

    end
  end
end
